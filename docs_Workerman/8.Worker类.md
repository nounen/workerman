* http://doc.workerman.net/315127

## Worker类
* WorkerMan 中有两个重要的类 `Worker` 与 `Connection`

* Worker 类用于实现端口的监听，并可以设置客户端连接事件、连接上消息事件、连接断开事件的回调函数，从而实现业务处理

* 可以设置 Worker 实例的进程数（count属性），Worker **主进程** 会 fork 出 count 个 **子进程** 同时监听相同的端口，并行的接收客户端连接，处理连接上的事件


### 构造函数
* `Worker::__construct([string $listen , array $context])`

* 参数: 
    * `$listen` 的格式为: <协议>://<监听地址>
        * 协议: eg: tcp udp unix http websocket
        * 监听地址: 如果是 unix 套接字，地址为本地一个磁盘路径, 非unix套接字，地址格式为 <本机ip>:<端口号>
        * TODO:一定要占用端口? 如果是使用域名呢?

    * `$context`: 一个数组。用于传递 socket 的上下文选项，参见套接字上下文选项 (http://php.net/manual/zh/context.socket.php)

* Worker监听自定义协议的端口
    * 目录结构:
    ```
    ├── Protocols              // 这是要创建的Protocols目录
    │   └── MyTextProtocol.php // 这是要创建的自定义协议文件
    ├── test.php  // 这是要创建的test脚本
    └── Workerman // Workerman源码目录，里面代码不要动
    ```    

    * TODO: 一个具体案例: http://doc.workerman.net/315128


### 属性
* id:
    * 说明: 当前 worker 进程的 id 编号，范围为 0 到 `$worker->count-1`

    * 注意:
        * 进程重启后 id 编号值是不变
        * 进程编号 id 的分配是基于每个 worker 实例的。每个 worker 实例都从 0 开始给自己的进程编号，所以 worker 实例间进程编号会有重复，但是一个 worker 实例中的进程编号不会重复

    * 案例: examples/8.worker        


* count:
    * 说明: 设置当前 Worker 实例启动多少个进程，不设置时默认为 1

* name: 
    * 说明: 设置当前 Worker 实力的名称, 方便运行 status 命令时识别进程。不设置时默认为none
        * php xxx.php status (TODO: 源码中怎么识别这个脚本的状态而不是当作新脚本?)

* protocol:
    * 说明: 设置当前 Worker 实例的协议类
        * eg: `$worker->protocol = 'Workerman\\Protocols\\Http';`:
            * 首先会查看用户是否有自定义 `\Protocols\Http` 协议类, 如果没有使用 workerman 内置协议类 `Workerman\Protocols\Http`

* transport:       
    * 说明: 设置当前Worker实例所使用的 **传输层协议**，目前只支持3种(tcp、udp、ssl)。不设置默认为tcp。
        * eg: `$worker->transport = 'udp'; // 使用udp协议`
        * TODO: 和 protocol 属性的差别 -- protocol 是编码解码的协议, transport 是传输层的协议. 具体阅读源码去理解.

* reusePort:
    * 说明: 设置当前worker是否开启监听端口复用(socket的 `SO_REUSEPORT` 选项)，默认为false，不开启
        * 开启监听端口复用后允许多个无亲缘关系的进程监听相同的端口，并且由系统内核做负载均衡，决定将 socket 连接交给哪个进程处理，避免了惊群效应，可以提升多进程短连接应用的性能
        * 注意： 此特性需要PHP版本 >=7.0

    * 范例:
        * 范例2：workerman多端口(多协议)监听 -- 6.reuse_port_multi_protocol.php

* connections:
    * 说明: 此属性中存储了 **当前进程** 的所有的 **客户端连接对象**，其中 id 为 connection 的id编号，详情见手册 `TcpConnection` 的 id 属性(http://doc.workerman.net/315338)
        * `$connections` 在广播时或者根据连接 id 获得连接对象非常有用;

        * 如果得知 connection 的编号为 `$id`，可以很方便的通过 `$worker->connections[$id]` 获得对应的 connection 对象，从而操作对应的 socket 连接，例如通过 `$worker->connections[$id]->send('...')` 发送数据

        * PS: 设置 count 能更好的理解 connections

* stdoutFile:
    * 说明: 此属性为全局静态属性，如果以守护进程方式(-d启动)运行，则所有向终端的输出(`echo var_dump`等)都会被重定向到 `stdoutFile` 指定的文件中     
        * 如果不设置，并且是以守护进程方式运行，则所有终端输出全部重定向到 `/dev/null`

* pidFile:
    * 说明: 此属性为全局静态属性，用来设置WorkerMan **进程的 pid 文件路径**
        * 如果无特殊需要，建议不要设置此属性;
        * 此项设置在监控中比较有用，例如将 WorkerMan 的 pid 文件放入固定的目录中，可以方便一些监控软件读取 pid 文件，从而监控 WorkerMan 进程状态;
        * 如果不设置，WorkerMan默认会在与Workerman目录平行的位置, 为了避免启动多个WorkerMan实例导致pid冲突，WorkerMan生成pid文件包含了当前WorkerMan的路径

* logFile:        
    * 说明: 此文件记录了workerman自身相关的日志，包括启动、停止等 (**不包含** 任何业务日志)
        * 如果没有设置，文件名默认为workerman.log，文件位置位于Workerman的上一级目录中;
        * 业务日志类可以利用 file_put_contents 或者 error_log 等函数自行实现
        